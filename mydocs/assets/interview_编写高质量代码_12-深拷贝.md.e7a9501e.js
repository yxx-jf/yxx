import{_ as e,c as a,o as i,a as d}from"./app.493ac1e4.js";const f=JSON.parse('{"title":"深拷贝","description":"","frontmatter":{},"headers":[{"level":2,"title":"题目","slug":"题目","link":"#题目","children":[]},{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[]},{"level":2,"title":"错误答案1","slug":"错误答案1","link":"#错误答案1","children":[]},{"level":2,"title":"错误答案2","slug":"错误答案2","link":"#错误答案2","children":[]},{"level":2,"title":"错误答案3","slug":"错误答案3","link":"#错误答案3","children":[]},{"level":2,"title":"正确答案","slug":"正确答案","link":"#正确答案","children":[]}],"relativePath":"interview/编写高质量代码/12-深拷贝.md"}'),l={name:"interview/编写高质量代码/12-深拷贝.md"},r=d('<h1 id="深拷贝" tabindex="-1">深拷贝 <a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-hidden="true">#</a></h2><p>手写 JS 深拷贝</p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-hidden="true">#</a></h2><p>这是一个很常见的问题，看似也很简单，但是如果考虑到“高质量代码”的要求，写起来还是挺麻烦的。<br> 别说写代码，就本节所有的情况你能否考虑全面，这都不一定。</p><h2 id="错误答案1" tabindex="-1">错误答案1 <a class="header-anchor" href="#错误答案1" aria-hidden="true">#</a></h2><p>使用 <code>JSON.stringify</code> 和 <code>JSON.parse</code></p><ul><li>无法转换函数</li><li>无法转换 <code>Map</code> <code>Set</code></li><li>无法转换循环引用</li></ul><p>PS：其实普通对象使用 JSON API 的运算速度很快，但功能不全</p><h2 id="错误答案2" tabindex="-1">错误答案2 <a class="header-anchor" href="#错误答案2" aria-hidden="true">#</a></h2><p>使用 <code>Object.assign</code> —— 这根本就不是深拷贝，是浅拷贝 ！！！</p><h2 id="错误答案3" tabindex="-1">错误答案3 <a class="header-anchor" href="#错误答案3" aria-hidden="true">#</a></h2><p>只考虑了普通的对象和数组</p><ul><li>无法转换 <code>Map</code> <code>Set</code></li><li>无法转换循环引用</li></ul><h2 id="正确答案" tabindex="-1">正确答案 <a class="header-anchor" href="#正确答案" aria-hidden="true">#</a></h2><p>参考代码 clone-deep.ts</p><hr><p>循环引用 Map Set 函数</p>',18),t=[r];function n(c,h,s,o,p,_){return i(),a("div",null,t)}const S=e(l,[["render",n]]);export{f as __pageData,S as default};
