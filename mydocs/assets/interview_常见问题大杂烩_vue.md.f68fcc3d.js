import{_ as e,c as t,o as a,a as d}from"./app.a28f8563.js";const m=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[{"level":2,"title":"vue项目在哪里配置最终打包生成文件的位置","slug":"vue项目在哪里配置最终打包生成文件的位置","link":"#vue项目在哪里配置最终打包生成文件的位置","children":[]},{"level":2,"title":"vue中sync修饰符的作用","slug":"vue中sync修饰符的作用","link":"#vue中sync修饰符的作用","children":[]},{"level":2,"title":"Vue有哪些事件修饰符","slug":"vue有哪些事件修饰符","link":"#vue有哪些事件修饰符","children":[]},{"level":2,"title":"使用v-model不同的表单控件是如何绑定值的","slug":"使用v-model不同的表单控件是如何绑定值的","link":"#使用v-model不同的表单控件是如何绑定值的","children":[]},{"level":2,"title":"vue中给data中的对象属性添加新属性的方法","slug":"vue中给data中的对象属性添加新属性的方法","link":"#vue中给data中的对象属性添加新属性的方法","children":[]},{"level":2,"title":"vue的计算属性","slug":"vue的计算属性","link":"#vue的计算属性","children":[]},{"level":2,"title":"vue指令","slug":"vue指令","link":"#vue指令","children":[]},{"level":2,"title":"$nextTick","slug":"nexttick","link":"#nexttick","children":[]},{"level":2,"title":"生命周期函数","slug":"生命周期函数","link":"#生命周期函数","children":[]},{"level":2,"title":"watch","slug":"watch","link":"#watch","children":[]},{"level":2,"title":"vue-router守卫","slug":"vue-router守卫","link":"#vue-router守卫","children":[]},{"level":2,"title":"组件库","slug":"组件库","link":"#组件库","children":[]},{"level":2,"title":"vuex","slug":"vuex","link":"#vuex","children":[]},{"level":2,"title":"vue组件间通信","slug":"vue组件间通信","link":"#vue组件间通信","children":[]},{"level":2,"title":"vue中如何自定义指令","slug":"vue中如何自定义指令","link":"#vue中如何自定义指令","children":[]},{"level":2,"title":"组合式api","slug":"组合式api","link":"#组合式api","children":[]},{"level":2,"title":"在vue项目中如何处理网络请求的发送","slug":"在vue项目中如何处理网络请求的发送","link":"#在vue项目中如何处理网络请求的发送","children":[]},{"level":2,"title":"vue中key属性的作用","slug":"vue中key属性的作用","link":"#vue中key属性的作用","children":[]},{"level":2,"title":"vue-router的两种模式","slug":"vue-router的两种模式","link":"#vue-router的两种模式","children":[]},{"level":2,"title":"如何在项目中定义组件","slug":"如何在项目中定义组件","link":"#如何在项目中定义组件","children":[]},{"level":2,"title":"vuex中如何调用mutations","slug":"vuex中如何调用mutations","link":"#vuex中如何调用mutations","children":[]},{"level":2,"title":"什么是插槽","slug":"什么是插槽","link":"#什么是插槽","children":[]},{"level":2,"title":"$router 和$route","slug":"router-和-route","link":"#router-和-route","children":[]},{"level":2,"title":"vue父组件调用子组件的方法","slug":"vue父组件调用子组件的方法","link":"#vue父组件调用子组件的方法","children":[]},{"level":2,"title":"vue中如何进行深度监听","slug":"vue中如何进行深度监听","link":"#vue中如何进行深度监听","children":[]},{"level":2,"title":"vue3比vue2新增特性","slug":"vue3比vue2新增特性","link":"#vue3比vue2新增特性","children":[]},{"level":2,"title":"keep-alive的作用","slug":"keep-alive的作用","link":"#keep-alive的作用","children":[]},{"level":2,"title":"vue组件的data为什么必须是函数","slug":"vue组件的data为什么必须是函数","link":"#vue组件的data为什么必须是函数","children":[]},{"level":2,"title":"vue2双向绑定的原理","slug":"vue2双向绑定的原理","link":"#vue2双向绑定的原理","children":[]},{"level":2,"title":"created和mounted的区别","slug":"created和mounted的区别","link":"#created和mounted的区别","children":[]},{"level":2,"title":"vue3相比于vue2的优势","slug":"vue3相比于vue2的优势","link":"#vue3相比于vue2的优势","children":[]}],"relativePath":"interview/常见问题大杂烩/vue.md"}'),o={name:"interview/常见问题大杂烩/vue.md"},r=d(`<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-hidden="true">#</a></h1><h2 id="vue项目在哪里配置最终打包生成文件的位置" tabindex="-1">vue项目在哪里配置最终打包生成文件的位置 <a class="header-anchor" href="#vue项目在哪里配置最终打包生成文件的位置" aria-hidden="true">#</a></h2><p>vue.config.js</p><h2 id="vue中sync修饰符的作用" tabindex="-1">vue中sync修饰符的作用 <a class="header-anchor" href="#vue中sync修饰符的作用" aria-hidden="true">#</a></h2><p>如果对于一个组件的属性，既要向它传递值，也要根据组建中的操作更新父组件的这个值，就可以通过sync这个修饰符进行快速绑定</p><h2 id="vue有哪些事件修饰符" tabindex="-1">Vue有哪些事件修饰符 <a class="header-anchor" href="#vue有哪些事件修饰符" aria-hidden="true">#</a></h2><p>once、stop、prevent、capture、self、passive</p><h2 id="使用v-model不同的表单控件是如何绑定值的" tabindex="-1">使用v-model不同的表单控件是如何绑定值的 <a class="header-anchor" href="#使用v-model不同的表单控件是如何绑定值的" aria-hidden="true">#</a></h2><p>文本属性框和多行文本输入框 绑定一个字符串</p><p>单个复选框 绑定一个布尔值</p><p>对于多个单选 绑定某个选项的value</p><p>对于多个多选框 绑定由选中的value值组成的数据</p><h2 id="vue中给data中的对象属性添加新属性的方法" tabindex="-1">vue中给data中的对象属性添加新属性的方法 <a class="header-anchor" href="#vue中给data中的对象属性添加新属性的方法" aria-hidden="true">#</a></h2><p>vue.set() this.$set()</p><h2 id="vue的计算属性" tabindex="-1">vue的计算属性 <a class="header-anchor" href="#vue的计算属性" aria-hidden="true">#</a></h2><blockquote><p>计算属性用computed来定义，是用来缓存一些通过计算才能得到的结果，定义为计算属性，可以节省整个的运算量；</p></blockquote><ul><li><p>比如：订单数组，如果想要在页面中显示不同状态的订单就可以通过定义计算属性的方式把不同的状态的数组分别获取到；</p></li><li><p>比如：计算订单总价，也可以通过计算属性去获取</p></li></ul><h2 id="vue指令" tabindex="-1">vue指令 <a class="header-anchor" href="#vue指令" aria-hidden="true">#</a></h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>v-bind</td><td><strong>缩写</strong>：<code>:</code> 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式等</td></tr><tr><td>v-html</td><td>更新元素的 <code>innerHTML</code>（双大括号会将数据解释为纯文本，而非 HTML ）</td></tr><tr><td>v-text</td><td>更新元素的 <code>textContent</code>，给元素绑定文本内容</td></tr><tr><td>v-if、v-else、v-else-if</td><td>根据表达式的值来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code>，将提出它的内容作为条件块。</td></tr><tr><td>v-for</td><td>基于一个数组渲染一个列表，它和JavaScript的遍历语法相似。</td></tr><tr><td>v-on</td><td>用于给监听DOM事件；<strong>缩写</strong>：<code>@ </code> <strong>参数</strong>：<code>event</code> 事件类型由参数指定</td></tr><tr><td>v-slot</td><td><strong>缩写</strong>：<code>#</code> 插槽：提供具名插槽或需要接收 prop 的插槽。</td></tr><tr><td>v-model</td><td>表单元素双向数据绑定（<strong>只能用于表单元素</strong>）</td></tr><tr><td>v-clock</td><td>绑定于内容的渲染阶段，可以借助css的属性选择器进行内容的渲染前隐藏</td></tr><tr><td>v-show</td><td>通过display控制元素的显示隐藏更适合频繁切换的场景</td></tr></tbody></table><h2 id="nexttick" tabindex="-1">$nextTick <a class="header-anchor" href="#nexttick" aria-hidden="true">#</a></h2><p>vue中 <code>vue.$nextTick this.$nextTick</code>，表示将回调函数中的内容放置到下一次事件循环执行，vue更新数据时数据是同步更新的但是<code>dom</code>是异步更新的，所以我们如果需要在dom更新后获取到最新的状态，那么就需要<code>$nextTick</code>来实现</p><h2 id="生命周期函数" tabindex="-1">生命周期函数 <a class="header-anchor" href="#生命周期函数" aria-hidden="true">#</a></h2><blockquote><p>其中前四个组件渲染阶段必定会执行的操作</p><p>mounted表示渲染完成，所以一般发起数据请求更新页面内容都会放置到mounted中来完成</p></blockquote><table><thead><tr><th>钩子函数</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</td></tr><tr><td>created</td><td>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用。</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</td></tr><tr><td>beforeUpdate</td><td>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</td></tr><tr><td>updated</td><td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</td></tr><tr><td>beforeDestroy</td><td>实例销毁之前调用。在这一步，实例仍然完全可用。</td></tr><tr><td>destroyed</td><td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</td></tr></tbody></table><h2 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-hidden="true">#</a></h2><blockquote><p>vue中的侦听器配置</p></blockquote><p>vue当中会对所有的data中的变量添加数据监听，会在值改变时通知所有引用data中的值得地方进行更新，就是可以在vue内部的监听之外额外设置自己的监听，一般在watch中进行的都是开销比较大的操作，比如数据请求</p><h2 id="vue-router守卫" tabindex="-1">vue-router守卫 <a class="header-anchor" href="#vue-router守卫" aria-hidden="true">#</a></h2><ul><li>全局守卫:<code>beforeEach</code>(全局前置守卫)、<code>beforeResolve</code>(全局解析守卫)、<code>afterEach</code>(全局后置钩子)</li><li>路由独享守卫:<code>beforeEnter</code>(在路由中定义的守卫)、</li><li>组件内部守卫 ：<code>beforeRouteEnter</code>(进入)、<code>beforeRouteUpdate</code>(更新)、<code>beforeRouteLeave</code>(离开)</li></ul><ol><li><code>beforeRouteEnter</code> 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 <code>this</code>，组件实例还没被创建</li><li><code>beforeRouteUpdate</code> (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 <code>this</code></li><li><code>beforeRouteLeave</code> 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 <code>this</code></li></ol><h2 id="组件库" tabindex="-1">组件库 <a class="header-anchor" href="#组件库" aria-hidden="true">#</a></h2><p>vue2：element UI； vue3:element Plus 小程序:weiui uniapp混合开发:uview组件库</p><h2 id="vuex" tabindex="-1">vuex <a class="header-anchor" href="#vuex" aria-hidden="true">#</a></h2><blockquote><p><code>vuex</code>是一个状态管理工具，使用集中式存储管理应用的所有组件的状态，解决多组件数据通信，将需要共享的数据保存在vuex中</p></blockquote><ul><li><code>vuex</code>重要核心属性:<code>state</code>、<code>mutations</code>、<code>actions</code>、<code>getters</code>、<code>modules</code></li><li><code>state</code>:保存着全局变量，就是公共数据</li><li><code>mutations</code>:用它来修改数据(类似于<code>methods</code>)</li><li><code>getters</code>:类似于<code>computed</code>(计算属性，对现有状态进行计算得到新的数据——派生)</li><li><code>actions</code>:发送异步请求</li><li><code>modules</code>:，当一个项目十分复杂的时候，可以进行模块划分，每一个模块都有自己的<code>state</code>、<code>mutations</code>、<code>gtters</code>、<code>actions</code>。</li><li><code>vuex</code>的辅助函数:<code>mapState</code>、<code>mapActions</code>、<code>mapGetters</code>、<code>mapMutations</code></li></ul><h2 id="vue组件间通信" tabindex="-1">vue组件间通信 <a class="header-anchor" href="#vue组件间通信" aria-hidden="true">#</a></h2><p>父子组件通信: props、$emit</p><p>上下级组件通信: $root、$parent、$refs</p><p>上下级组件(相聚较远):provide、inject</p><p>同级组件:event hub 利用vue 借助于事件api $on $emit实现数据传递</p><p>vuex处理复杂的组件间共享的业务逻辑问题</p><h2 id="vue中如何自定义指令" tabindex="-1">vue中如何自定义指令 <a class="header-anchor" href="#vue中如何自定义指令" aria-hidden="true">#</a></h2><p>全局定义:<code>vue.directive</code>/局部定义:<code>{directives:{}}</code></p><p>指令名称、指令相关的钩子函数</p><p>vue2:<code>inserted()</code></p><p>vue3：和组件保持一致()</p><p>在钩子函数中可以接收和操作的值，可以接收到当前元素原生对象，可以接收指令的参数、指令的值、指令的修饰符等等，根据这些值可以对元素添加相应的操作</p><h2 id="组合式api" tabindex="-1">组合式api <a class="header-anchor" href="#组合式api" aria-hidden="true">#</a></h2><p><code>ref</code> 将一个普通值变为响应式的值 后续要操作它的值必须通过value属性操作</p><p><code>reactive</code> 将一个普通对象变为响应式对象 后续直接操作对象属性就会触发响应式的内容更新</p><h2 id="在vue项目中如何处理网络请求的发送" tabindex="-1">在vue项目中如何处理网络请求的发送 <a class="header-anchor" href="#在vue项目中如何处理网络请求的发送" aria-hidden="true">#</a></h2><p>首先基于axios进行请求发送的，</p><p>因为axios不同类型的请求格式不一致，所以我们自己会重新同意封装接口，保证格式一致</p><p>会同意添加请求拦截和响应拦截，处理token相关的一些业务，</p><p>会将请求地址统一放置到一个文件当中</p><p>发送请求的时候使用async和await进行具体请求的处理</p><h2 id="vue中key属性的作用" tabindex="-1">vue中key属性的作用 <a class="header-anchor" href="#vue中key属性的作用" aria-hidden="true">#</a></h2><p>在使用<code>v-for、v-if、v-else</code>的时候可以通过key属性可以给每个元素添加一个唯一标识，为了在内容进行更新的时候可以更加高效的更新特定的元素</p><h2 id="vue-router的两种模式" tabindex="-1">vue-router的两种模式 <a class="header-anchor" href="#vue-router的两种模式" aria-hidden="true">#</a></h2><p>v-router实现的是前台路由的效果，也就是在网页不发生真正跳转的情况下地址和页面内容都发生改变的效果，要实现前台路由有两种方式，一种是基于h5的<code>history API(history.pushstate、window.on。。。)</code>，另外一种是基于路径的<code>hash</code>部分，<code>window.onhashchange</code>事件，所以对应到<code>vue-router</code>当中就有两种模式，一种就是<code>hash</code>模式，一种是<code>history</code>模式</p><h2 id="如何在项目中定义组件" tabindex="-1">如何在项目中定义组件 <a class="header-anchor" href="#如何在项目中定义组件" aria-hidden="true">#</a></h2><p>首先会将需要作为组件的布局代码和样式代码抽取出来放置到一个单独的<code>.vue</code>文件当中</p><p>在组件中定义组件内部数据状态(<code>data</code>)和事件监听(<code>methods</code>)</p><p>定义组件外部属性(<code>props</code>)和需要广播的事件(<code>$emit/vue3 emits</code>)，</p><h2 id="vuex中如何调用mutations" tabindex="-1">vuex中如何调用mutations <a class="header-anchor" href="#vuex中如何调用mutations" aria-hidden="true">#</a></h2><p>mutations是用来定义操作<code>state</code>方法的</p><p><code>this.$store.commit{&quot;add&quot;,(num:1)}</code></p><p>借助于<code>mapMutations()</code>这个辅助函数，可以直接将<code>mutations</code>扩展到methods中，然后就可以通过this直接调用了</p><h2 id="什么是插槽" tabindex="-1">什么是插槽 <a class="header-anchor" href="#什么是插槽" aria-hidden="true">#</a></h2><p>在组件内部如果有部分内容需要调用组件的时候再指定就可以通过在组件内部通过<code>slot</code>标签来进行插槽位置的一个指定，插槽可以命名也可以通过插槽向外传递组件内部的数据</p><h2 id="router-和-route" tabindex="-1">$router 和$route <a class="header-anchor" href="#router-和-route" aria-hidden="true">#</a></h2><p>$router是路由实例对象，内部包含一些用于跳转和动态添加路由等的方法</p><p>$route是当前页面的路由信息对象，内部包含当前页面路径path、查询参数query、路径参数params、元信息meta等信息的对象</p><h2 id="vue父组件调用子组件的方法" tabindex="-1">vue父组件调用子组件的方法 <a class="header-anchor" href="#vue父组件调用子组件的方法" aria-hidden="true">#</a></h2><p><code>$refs</code>找到子组件就可以调用了</p><h2 id="vue中如何进行深度监听" tabindex="-1">vue中如何进行深度监听 <a class="header-anchor" href="#vue中如何进行深度监听" aria-hidden="true">#</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">watch</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">name</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){},</span></span>
<span class="line"><span style="color:#FFCB6B;">obj</span><span style="color:#89DDFF;">:{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">handler</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){},</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">deep</span><span style="color:#89DDFF;">:</span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="vue3比vue2新增特性" tabindex="-1">vue3比vue2新增特性 <a class="header-anchor" href="#vue3比vue2新增特性" aria-hidden="true">#</a></h2><p>新增的组合式<code>api:ref、reactive、computed、watch、watchEffect、readOnly、mounted...</code></p><p>teleport</p><p>多个根节点</p><p>v-model指令的参数</p><p>emits配置项</p><h2 id="keep-alive的作用" tabindex="-1">keep-alive的作用 <a class="header-anchor" href="#keep-alive的作用" aria-hidden="true">#</a></h2><p>保持动态组件内部的状态在失活时不变</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">is</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">compName</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">component</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">router-view</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">router-view</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h2 id="vue组件的data为什么必须是函数" tabindex="-1">vue组件的data为什么必须是函数 <a class="header-anchor" href="#vue组件的data为什么必须是函数" aria-hidden="true">#</a></h2><p>因为组件是要被复用的 如果以对象的方式定义data，不同组件引用的就是同一个data对象，就会互相影响，所以我们需要每个组件返回一个新的对象</p><h2 id="vue2双向绑定的原理" tabindex="-1">vue2双向绑定的原理 <a class="header-anchor" href="#vue2双向绑定的原理" aria-hidden="true">#</a></h2><p>首先会遍历data，使用defineProperty拦截所有属性，当用户操作视图时会触发set拦截器，set首先会改变当前的数据，然后通知watch，让watch通知视图进行更新，视图重绘，再次从get中获取相应的数据。 vue2是浅响应式。</p><h2 id="created和mounted的区别" tabindex="-1">created和mounted的区别 <a class="header-anchor" href="#created和mounted的区别" aria-hidden="true">#</a></h2><p>在created当中是获取不到渲染后的dom内容的而在mounted中可以</p><h2 id="vue3相比于vue2的优势" tabindex="-1">vue3相比于vue2的优势 <a class="header-anchor" href="#vue3相比于vue2的优势" aria-hidden="true">#</a></h2><p>vue3采用proxy而不是vue2的defineProperty，所以对于数据变化的监听有更高的执行效率，</p><p>vue3与typescript结合的更好，</p><p>vue3体积要比vue2更小</p><p>vue3中新增了很多功能特性，比如说组合式api、v-model...</p>`,97),l=[r];function n(s,c,i,u,p,h){return a(),t("div",null,l)}const y=e(o,[["render",n]]);export{m as __pageData,y as default};
