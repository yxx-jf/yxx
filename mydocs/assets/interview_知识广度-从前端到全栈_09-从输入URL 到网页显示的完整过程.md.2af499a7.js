import{_ as l,c as e,o as i,a as c}from"./app.f7b0898d.js";const d="/mydocs/render.png",g=JSON.parse('{"title":"从输入URL 到网页显示的完整过程","description":"","frontmatter":{},"headers":[{"level":2,"title":"步骤","slug":"步骤","link":"#步骤","children":[]},{"level":2,"title":"网络请求","slug":"网络请求","link":"#网络请求","children":[]},{"level":2,"title":"解析","slug":"解析","link":"#解析","children":[]},{"level":2,"title":"渲染页面","slug":"渲染页面","link":"#渲染页面","children":[]},{"level":2,"title":"什么是 重绘 repaint 和 重排(回流） reflow ，有何区别","slug":"什么是-重绘-repaint-和-重排-回流-reflow-有何区别","link":"#什么是-重绘-repaint-和-重排-回流-reflow-有何区别","children":[{"level":3,"title":"减少重排的方法","slug":"减少重排的方法","link":"#减少重排的方法","children":[]}]},{"level":2,"title":"触发 css BFC 的条件","slug":"触发-css-bfc-的条件","link":"#触发-css-bfc-的条件","children":[]}],"relativePath":"interview/知识广度-从前端到全栈/09-从输入URL 到网页显示的完整过程.md"}'),t={name:"interview/知识广度-从前端到全栈/09-从输入URL 到网页显示的完整过程.md"},o=c('<h1 id="从输入url-到网页显示的完整过程" tabindex="-1">从输入URL 到网页显示的完整过程 <a class="header-anchor" href="#从输入url-到网页显示的完整过程" aria-hidden="true">#</a></h1><ul><li>网络请求 <ul><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求和响应</li></ul></li><li>解析 <ul><li>DOM 树</li><li>CSSOM 树</li><li>render tree</li></ul></li><li>渲染页面 <ul><li>计算</li><li>绘制</li><li>可能重绘页面</li></ul></li></ul><h2 id="步骤" tabindex="-1">步骤 <a class="header-anchor" href="#步骤" aria-hidden="true">#</a></h2><ul><li>网络请求</li><li>解析</li><li>渲染页面</li></ul><h2 id="网络请求" tabindex="-1">网络请求 <a class="header-anchor" href="#网络请求" aria-hidden="true">#</a></h2><ul><li>DNS 解析，根据域名获得 IP 地址</li><li>建立 TCP 连接 “三次握手”</li><li>发送 http 请求</li><li>接收请求响应，获得网页 html 代码</li></ul><p>获取了 html 之后，解析过程中还可能会继续加载其他资源：js css 图片等。<br> 静态资源可能会有强缓存，加载时要判断。</p><h2 id="解析" tabindex="-1">解析 <a class="header-anchor" href="#解析" aria-hidden="true">#</a></h2><blockquote><p>html css 等源代码是字符串形式，需要解析为特定的数据结构，才能被后续使用。</p></blockquote><p>过程</p><ul><li>html 构建 DOM 树</li><li>css 构建 CSSOM（即 style tree）</li><li>两者结合形成 Render tree （包括尺寸、定位等）</li></ul><p><img src="'+d+'" alt="" data-fancybox="gallery"></p><p>css 包括：</p><ul><li>内嵌 css <code>&lt;style&gt;</code></li><li>外链 css <code>&lt;link&gt;</code></li></ul><p>解析到 <code>&lt;script&gt;</code> 加载，并有可能修改 DOM 树和 render tree 。</p><ul><li>内嵌 js</li><li>外链 js</li></ul><p>PS：加载和执行 <code>&lt;script&gt;</code> 的情况比较多，如有 <code>defer</code> <code>async</code> 属性，就不一样。</p><p>解析到 <code>&lt;img&gt;</code> 等媒体文件，也要并行加载。加载完成后再渲染页面。</p><p>综上，为了避免不必要的情况，要遵守以下规则</p><ul><li>css 尽量放在 <code>&lt;head&gt;</code> 中，不要异步加载 css</li><li>js 尽量放在 <code>&lt;body&gt;</code> 最后，不要中途加载、执行 js</li><li><code>&lt;img&gt;</code> 等媒体文件尽量限制尺寸，防止渲染时重绘页面</li></ul><h2 id="渲染页面" tabindex="-1">渲染页面 <a class="header-anchor" href="#渲染页面" aria-hidden="true">#</a></h2><p>通过 render tree 绘制页面。</p><p>绘制完成之后，还要继续执行异步加载的资源</p><ul><li>异步的 css ，重新渲染页面</li><li>异步的 js ，执行（可能重新渲染页面）</li><li>异步加载的图片、css等，可能会重新渲染页面（根据图片尺寸）</li></ul><p>最后页面渲染完成。</p><h2 id="什么是-重绘-repaint-和-重排-回流-reflow-有何区别" tabindex="-1">什么是 重绘 repaint 和 重排(回流） reflow ，有何区别 <a class="header-anchor" href="#什么是-重绘-repaint-和-重排-回流-reflow-有何区别" aria-hidden="true">#</a></h2><ul><li>重绘 repaint ：某些元素的外观被改变，但尺寸和定位不变，例如：元素的背景色改变。</li><li>重排(回流） reflow ：重新生成布局，重新排列元素。如一个元素高度变化，导致所有元素都下移。</li></ul><p>页面渲染完成之后，随着异步加载和用户的操作，会随时发生 重绘 repaint 或者 重排 reflow 。例如：</p><ul><li>各种网页动画</li><li>modal dialog 弹框</li><li>页面元素的新增、删除和隐藏</li></ul><p><strong>结论</strong>：重排的影响更大</p><p><strong>重绘不一定重排，但重排一定会导致重绘。<br> 所以，要尽量避免重排。</strong></p><h3 id="减少重排的方法" tabindex="-1">减少重排的方法 <a class="header-anchor" href="#减少重排的方法" aria-hidden="true">#</a></h3><ul><li>集中修改样式，或直接使用 <code>class</code></li><li>DOM 操作前先使用 <code>display: none</code> 脱离文档流</li><li>脱离文档流的元素（比如绝对定位）不会造成重排</li><li>使用 BFC ，不影响外部的元素</li><li>对于频繁触发的操作（<code>resize</code> <code>scroll</code> 等）使用节流和防抖</li><li>使用 <code>createDocumentFragment</code> 进行批量 DOM 操作</li><li>优化动画，如使用 <code>requestAnimationFrame</code> 或者 CSS3（可启用 GPU 加速）</li></ul><h2 id="触发-css-bfc-的条件" tabindex="-1">触发 css BFC 的条件 <a class="header-anchor" href="#触发-css-bfc-的条件" aria-hidden="true">#</a></h2><p>BFC - Block Formatting Context 块格式化上下文</p><ul><li>根节点 html</li><li>设置 float <code>left</code> <code>right</code></li><li>设置 overflow <code>auto</code> <code>scroll</code> <code>hidden</code></li><li>设置 display <code>inline-block</code> <code>table</code> <code>table-cell</code> <code>flex</code> <code>grid</code></li><li>设置 position <code>absolute</code> <code>fixed</code></li></ul>',36),r=[o];function a(s,n,h,p,u,_){return i(),e("div",null,r)}const m=l(t,[["render",a]]);export{g as __pageData,m as default};
