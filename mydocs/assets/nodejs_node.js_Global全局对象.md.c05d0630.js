import{_ as s,c as a,o as n,a as l,b as t,e}from"./app.ad3b77f8.js";const x=JSON.parse('{"title":"Global全局对象","description":"","frontmatter":{},"headers":[{"level":2,"title":"Process","slug":"process","link":"#process","children":[]},{"level":2,"title":"URL","slug":"url","link":"#url","children":[]},{"level":2,"title":"Buffer","slug":"buffer","link":"#buffer","children":[]},{"level":2,"title":"Console模块","slug":"console模块","link":"#console模块","children":[]},{"level":2,"title":"Global方法","slug":"global方法","link":"#global方法","children":[]}],"relativePath":"nodejs/node.js/Global全局对象.md"}'),d={name:"nodejs/node.js/Global全局对象.md"},o=l(`<h1 id="global全局对象" tabindex="-1">Global全局对象 <a class="header-anchor" href="#global全局对象" aria-hidden="true">#</a></h1><blockquote><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p></blockquote><p>在浏览器端的 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p><ul><li>Javascript中的全局对象 window</li><li>node.js中的全局对象 global</li></ul><p>global最根本的作用是作为全局变量的宿主，据ECMAScript的定义，满足以下条件的变量都是全局变量</p><ul><li>在最外层定义的变量</li><li>全局对象的属性</li><li>隐式定义的变量 在Node.js中不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。</li></ul><p>全局空间可以访问console,process,buffer等模块，不需要require。</p><p>Global对象属性与方法</p><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">类型</th><th style="text-align:left;">介绍</th></tr></thead><tbody><tr><td style="text-align:left;"><code>global.global</code></td><td style="text-align:left;">对象</td><td style="text-align:left;">global本身</td></tr><tr><td style="text-align:left;"><code>global.process</code></td><td style="text-align:left;">对象</td><td style="text-align:left;">操作进程、访问进程的相关信息</td></tr><tr><td style="text-align:left;"><code>global.console</code></td><td style="text-align:left;">对象</td><td style="text-align:left;">与浏览器调试工具console类似</td></tr><tr><td style="text-align:left;"><code>global.Buffer</code></td><td style="text-align:left;">类</td><td style="text-align:left;">处理二进制数据</td></tr><tr><td style="text-align:left;"><code>global.URL</code></td><td style="text-align:left;">类</td><td style="text-align:left;">用于网址处理与解析</td></tr><tr><td style="text-align:left;"><code>setTimeout(fn,ms)</code></td><td style="text-align:left;">函数</td><td style="text-align:left;">延时定时器</td></tr><tr><td style="text-align:left;"><code>clearTimeout(timeout)</code></td><td style="text-align:left;">函数</td><td style="text-align:left;">取消延迟定时器</td></tr><tr><td style="text-align:left;"><code>setInterval(fn,ms)</code></td><td style="text-align:left;">函数</td><td style="text-align:left;">时间间隔定时器</td></tr><tr><td style="text-align:left;"><code>clearInterval(timeout)</code></td><td style="text-align:left;">函数</td><td style="text-align:left;">取消延时间间隔定时器</td></tr><tr><td style="text-align:left;"><code>setImmediate(callback[, ...args])</code></td><td style="text-align:left;">函数</td><td style="text-align:left;">在事件循环的当前回合结束时要调用的函数。</td></tr><tr><td style="text-align:left;"><code>clearImmediate(immediate)</code></td><td style="text-align:left;">函数</td><td style="text-align:left;">取消一个由 <code>setImmediate()</code> 创建的 Immediate对象</td></tr></tbody></table><h2 id="process" tabindex="-1">Process <a class="header-anchor" href="#process" aria-hidden="true">#</a></h2><blockquote><p>process是一个全局变量，即global对象的属性，它用来操作或者是获取或者查看当前进程的相关信息。</p></blockquote><p>process属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>process.argv</td><td>是用来获取或查看当前进程的相关信息。</td></tr><tr><td>process.arch</td><td>获取程序运行平台处理器架构 &#39;x64&#39;、&#39;x86&#39;</td></tr><tr><td>process.platform</td><td>运行程序所在的平台系统 &#39;darwin&#39;, &#39;freebsd&#39;, &#39;linux&#39;, &#39;sunos&#39; 或 &#39;win32&#39;</td></tr><tr><td>process.version</td><td>Node的版本</td></tr><tr><td>process.versions</td><td>包含了Node的版本和依赖</td></tr><tr><td>p<wbr>rocess.env</td><td>p<wbr>rocess.env 是 Node.js 中的一个环境对象。其中保存着系统的环境的变量信息。</td></tr></tbody></table><p>p<wbr>rocess.env</p><p>p<wbr>rocess.env 是 Node.js 中的一个环境对象。其中保存着系统的环境的变量信息。NODE_ENV 就是其中的一个环境变量。这个变量主要用于标识当前的环境（生产环境，开发环境）。默认是没有这个环境变量的，需要自己手动配置。</p><p>使用频率很高，node服务运行时，时常会判断当前服务运行的环境，如下所示</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">if(p<wbr>rocess.env.NODE_ENV === &#39;production&#39;){</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;生产环境&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}else{</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;非生产环境&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>process方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>process.cwd()</td><td>查看当前进程的工作目录</td></tr><tr><td>process.chdir()</td><td>更改当前进程的工作目录</td></tr><tr><td>process.memoryUsage()</td><td>内存使用情况 heapTotal代表已申请到的堆内存，heapUsed当前使用的内存，rss(resident set size)进程的常驻内存(单位字节byte)</td></tr><tr><td>process.nextTick(callback)</td><td>一旦当前事件循环结束，调用回到函数。</td></tr><tr><td>process.uptime()</td><td>返回 Node 已经运行的秒数。</td></tr><tr><td>process.uptime()</td><td>返回 Node 已经运行的秒数。</td></tr></tbody></table><h2 id="url" tabindex="-1">URL <a class="header-anchor" href="#url" aria-hidden="true">#</a></h2><blockquote><p>在我们开发Web应用时，经常需要处理URL，Nodejs给我们提供了URL类来处理URL。</p></blockquote><p><strong>URL组成部分</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">┌────────────────────────────────────────────────────────────────────────────────────────────────┐</span></span>
<span class="line"><span style="color:#A6ACCD;">│                                              href                                              │</span></span>
<span class="line"><span style="color:#A6ACCD;">├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤</span></span>
<span class="line"><span style="color:#A6ACCD;">│ protocol │  │        auth         │          host          │           path            │ hash  │</span></span>
<span class="line"><span style="color:#A6ACCD;">│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │</span></span>
<span class="line"><span style="color:#A6ACCD;">│          │  │                     │    hostname     │ port │ pathname │     search     │       │</span></span>
<span class="line"><span style="color:#A6ACCD;">│          │  │                     │                 │      │          ├─┬──────────────┤       │</span></span>
<span class="line"><span style="color:#A6ACCD;">│          │  │                     │                 │      │          │ │    query     │       │</span></span>
<span class="line"><span style="color:#A6ACCD;">&quot;  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash &quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">│          │  │          │          │    hostname     │ port │          │                │       │</span></span>
<span class="line"><span style="color:#A6ACCD;">│          │  │          │          ├─────────────────┴──────┤          │                │       │</span></span>
<span class="line"><span style="color:#A6ACCD;">│ protocol │  │ username │ password │          host          │          │                │       │</span></span>
<span class="line"><span style="color:#A6ACCD;">├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │</span></span>
<span class="line"><span style="color:#A6ACCD;">│   origin    │                     │         origin         │ pathname │     search     │ hash  │</span></span>
<span class="line"><span style="color:#A6ACCD;">├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤</span></span>
<span class="line"><span style="color:#A6ACCD;">│                                              href                                              │</span></span>
<span class="line"><span style="color:#A6ACCD;">└────────────────────────────────────────────────────────────────────────────────────────────────┘</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>对于一个 URL 字符串，其组成部分会有所有不同，其中有些部分只有在URL字符串中存在时，对应字段才会出现在解析后对象中。以下是一个 URL 例子：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">http://user:pass@host.com:8080/p/a/t/h?query=string#hash</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>解析后对象字段如下：</p>`,26),r=t("table",null,[t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"left"}},"参数"),t("th",{style:{"text-align":"left"}},"描述"),t("th",{style:{"text-align":"left"}},"示例")])]),t("tbody",null,[t("tr",null,[t("td",{style:{"text-align":"left"}},"href"),t("td",{style:{"text-align":"left"}},"解析前的完整原始 URL，协议名和主机名已转为小写"),t("td",{style:{"text-align":"left"}},[t("a",{href:"http://user:pass@host.com:8080/p/a/t/h?query=string#hash",target:"_blank",rel:"noreferrer"},"http://user:pass@host.com:8080/p/a/t/h?query=string#hash")])]),t("tr",null,[t("td",{style:{"text-align":"left"}},"protocol"),t("td",{style:{"text-align":"left"}},"请求协议，小写"),t("td",{style:{"text-align":"left"}},"http:")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"slashes"),t("td",{style:{"text-align":"left"}},'协议的"："号后是否有"/"'),t("td",{style:{"text-align":"left"}},"true or false")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"host"),t("td",{style:{"text-align":"left"}},"URL主机名，包括端口信息，小写"),t("td",{style:{"text-align":"left"}},[e("'"),t("a",{href:"http://host.com:8080",target:"_blank",rel:"noreferrer"},"host.com:8080"),e("'")])]),t("tr",null,[t("td",{style:{"text-align":"left"}},"auth"),t("td",{style:{"text-align":"left"}},"URL中的认证信息"),t("td",{style:{"text-align":"left"}},"'user:pass'")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"hostname"),t("td",{style:{"text-align":"left"}},"主机名，小写"),t("td",{style:{"text-align":"left"}},[e("'"),t("a",{href:"http://host.com",target:"_blank",rel:"noreferrer"},"host.com"),e("'")])]),t("tr",null,[t("td",{style:{"text-align":"left"}},"port"),t("td",{style:{"text-align":"left"}},"主机的端口号"),t("td",{style:{"text-align":"left"}},"'8080'")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"pathname"),t("td",{style:{"text-align":"left"}},"URL中路径"),t("td",{style:{"text-align":"left"}},"'/p/a/t/h'")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"search"),t("td",{style:{"text-align":"left"}},"查询对象，即：queryString，包括之前的问号“?”"),t("td",{style:{"text-align":"left"}},"'?query=string'")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"path"),t("td",{style:{"text-align":"left"}},"pathname 和 search的合集"),t("td",{style:{"text-align":"left"}},"'/p/a/t/h?query=string'")]),t("tr",{"query:string":""},[t("td",{style:{"text-align":"left"}},"query"),t("td",{style:{"text-align":"left"}},"查询字符串中的参数部分（问号后面部分字符串）"),t("td",{style:{"text-align":"left"}},"'query=string' or")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"hash"),t("td",{style:{"text-align":"left"}},"锚点部分（即：“#”及其后的部分）"),t("td",{style:{"text-align":"left"}},"'#hash'")])])],-1),p=l(`<p><strong>URL 类</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">new URL(input[, base])</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">类型</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">input</td><td style="text-align:left;"><code>&lt;string&gt;</code></td><td style="text-align:left;">要解析的绝对或相对的输入网址。 如果 input 是相对的，则需要 base。 如果 input 是绝对的，则忽略 base。</td></tr><tr><td style="text-align:left;">base</td><td style="text-align:left;"><code>&lt;string&gt; /&lt;URL&gt;</code></td><td style="text-align:left;">如果 input 不是绝对的，则为要解析的基本网址。</td></tr></tbody></table><p>网址构造函数可作为全局对象的属性访问。 也可以从内置的 url 模块中导入：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">import { URL } from &#39;url&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(URL === globalThis.URL); // 打印 &#39;true&#39;.</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>url类的属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>url.href</td><td>获取和设置序列化的网址。</td></tr><tr><td>url.pathname</td><td>获取和设置网址的路径部分。</td></tr><tr><td>url.port</td><td>获取和设置网址的端口部分。端口值可以是数字，也可以是包含 0 到 65535（含）范围内的数字的字符串。 将值设置为给定 protocol 的 URL 对象的默认端口将导致 port 值成为空字符串 (&#39;&#39;)。</td></tr><tr><td>url.protocol</td><td>获取和设置网址的协议部分。</td></tr><tr><td>url.search</td><td>获取和设置网址的序列化的查询部分。</td></tr><tr><td>url.searchParams</td><td>获取表示网址查询参数的 URLSearchParams 对象。</td></tr><tr><td>url.hash</td><td>获取和设置网址的片段部分。</td></tr><tr><td>url.host</td><td>获取和设置网址的主机部分。</td></tr><tr><td>url.hostname</td><td>获取和设置网址的主机名部分。 url.host 和 url.hostname 之间的主要区别在于 url.hostname 不包括端口。</td></tr></tbody></table><h2 id="buffer" tabindex="-1">Buffer <a class="header-anchor" href="#buffer" aria-hidden="true">#</a></h2><blockquote><p>Buffer就是一个缓冲区（内存中的一块空间），主要是为了处理二进制的数据。</p><p>nodejs中新的数据类型，用来存储各种数据</p></blockquote><p>Buffer对象可以和字符串相互转换，支持的编码类型如下：ASCII、UTF-8、Base64、Binary(二进制)、Hex(十六进制)</p><p>Buffer使用</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Buffer.from(array)</td><td>创建</td><td>array 创建一个新的 Buffer</td></tr><tr><td>Buffer.from(string[,encoding])</td><td>创建</td><td>新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码。</td></tr><tr><td>Buffer.alloc(size[,val[,encoding]])</td><td>创建</td><td>分配一个大小为 size 字节的新建的 Buffer 。 如果 fill 为 undefined ，则该 Buffer 会用 0 填充。</td></tr><tr><td>Buffer.concat(list[,totallength])</td><td>合并</td><td>返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer</td></tr><tr><td>buf.toString([encoding], [start], [end])</td><td>返回</td><td>根据 encoding 指定的字符编码解码 buf 成一个字符串。</td></tr><tr><td>buf.toJSON()</td><td>返回</td><td>返回 buf 的 JSON 格式。</td></tr><tr><td>Buffer.isEncoding(encoding)</td><td>检测</td><td>如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。</td></tr><tr><td>Buffer.isBuffer(obj)</td><td>检测</td><td>如果 obj 是一个 Buffer 则返回 true ，否则返回 false 。</td></tr><tr><td>Buffer.byteLength(buf)</td><td>获取</td><td>获取字节长度</td></tr><tr><td>buf.equals(otherBuffer)</td><td>检测</td><td>如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。</td></tr></tbody></table><h2 id="console模块" tabindex="-1">Console模块 <a class="header-anchor" href="#console模块" aria-hidden="true">#</a></h2><blockquote><p>console模块是Node提供的核心模块，用于提供控制台标准输出。</p></blockquote><p>console对象方法如下：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>console.log()</td><td>在控制台输出。【类似的还有2-4，格式有%s,%d,%j(json格式)】</td></tr><tr><td><a href="http://console.info" target="_blank" rel="noreferrer">console.info</a>()</td><td>返回信息行消息</td></tr><tr><td>console.error()</td><td>在控制台输出一个错误的消息</td></tr><tr><td>console.warn()</td><td>输出警告消息</td></tr><tr><td>console.dir(object)</td><td>利用util.inspect()输出对象的分析</td></tr><tr><td>console.time()</td><td>在程序运行之前调用、记录当前的时间信息</td></tr><tr><td>console.timeEnd()</td><td>配合 onsole．time()，在程序运行完成之后调用，记录程序完成后的时间信息（即间隔的时间）</td></tr><tr><td>consle.trance()</td><td>追踪情况。</td></tr><tr><td>console.assert(expr,msg)</td><td>用于判断某个表达式或变量是否为真。若expr为假，则输出msg</td></tr></tbody></table><h2 id="global方法" tabindex="-1">Global方法 <a class="header-anchor" href="#global方法" aria-hidden="true">#</a></h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>setInterval(fn,ms)</code></td><td>全局函数在指定的毫秒(ms)数后执行指定的函数fn，重复执行</td></tr><tr><td><code>clearInterval(timeout)</code></td><td>取消一个由 <code>setInterval()</code> 创建的 Timeout 对象。</td></tr><tr><td><code>setTimeout(fn,ms)</code></td><td>全局函数在指定的毫秒(ms)数后执行指定的函数fn，只执行一次</td></tr><tr><td><code>clearTimeout(timeout)</code></td><td>全局函数用于停止一个之前通过<code>setTimeout()</code>创建的定时器</td></tr><tr><td><code>setImmediate(callback[, ...args])</code></td><td>在 Node.js 事件循环的当前回合结束时要调用的函数。</td></tr><tr><td><code>clearImmediate(immediate)</code></td><td>取消一个由 <code>setImmediate()</code> 创建的 Immediate对象</td></tr></tbody></table><p>setTimeout、setImmediate与process.nextTick 区别</p><div class="language-JS"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;"># 每次需要判断时间</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){},</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"># </span><span style="color:#82AAFF;">放到下一次事件循环</span><span style="color:#A6ACCD;">(第一个循环后和第二个循环前)执行 效率高，直接执行无需判断</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"># 放到当前任务末尾 效率高，直接执行无需判断</span></span>
<span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(callback)</span></span>
<span class="line"></span></code></pre></div>`,20),c=[o,r,p];function i(h,f,g,y,u,b){return n(),a("div",null,c)}const A=s(d,[["render",i]]);export{x as __pageData,A as default};
