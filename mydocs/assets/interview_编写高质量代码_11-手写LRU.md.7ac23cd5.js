import{_ as s,o as a,c as l,O as n}from"./chunks/framework.1d9da8ae.js";const o="/mydocs/img/双向链表-1.png",p="/mydocs/img/双向链表-2.png",h=JSON.parse('{"title":"手写 LRU","description":"","frontmatter":{},"headers":[],"relativePath":"interview/编写高质量代码/11-手写LRU.md","filePath":"interview/编写高质量代码/11-手写LRU.md"}'),e={name:"interview/编写高质量代码/11-手写LRU.md"},t=n(`<h1 id="手写-lru" tabindex="-1">手写 LRU <a class="header-anchor" href="#手写-lru" aria-label="Permalink to &quot;手写 LRU&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>用 JS 实现一个 LRU 缓存</p><h2 id="lru-使用" tabindex="-1">LRU 使用 <a class="header-anchor" href="#lru-使用" aria-label="Permalink to &quot;LRU 使用&quot;">​</a></h2><p>Least Recently Used 最近最少使用<br> 即淘汰掉最近最少使用的数据，只保留最近经常使用的资源。它是一个固定容量的缓存容器。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> lruCache </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">LRUCache</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 最大缓存长度 2</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 缓存是 {1=1}</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 缓存是 {1=1, 2=2}</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 返回 1</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 返回 null</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 返回 null</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 返回 3</span></span>
<span class="line"><span style="color:#A6ACCD;">lruCache</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 返回 4</span></span></code></pre></div><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><ul><li>哈希表，即 <code>{ k1: v1, k2: v2, ... }</code> 形式。可以 <code>O(1)</code> 事件复杂度存取 <code>key</code> <code>value</code></li><li>有序。可以根据最近使用情况清理缓存</li></ul><p>JS 内置的数据结构类型 <code>Object</code> <code>Array</code> <code>Set</code> <code>Map</code> ，恰好 <code>Map</code> 符合这两条要求</p><h2 id="map-是有序的" tabindex="-1">Map 是有序的 <a class="header-anchor" href="#map-是有序的" aria-label="Permalink to &quot;Map 是有序的&quot;">​</a></h2><p>Map 有序，Object 无序</p><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2><p>代码参考 LRU.ts</p><p>注意，<code>get</code> <code>set</code> 时都要把操作数据移动到 Map 最新的位置。</p><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>实际项目中可以使用第三方 lib</p><ul><li><a href="https://www.npmjs.com/package/quick-lru" target="_blank" rel="noreferrer">https://www.npmjs.com/package/quick-lru</a></li><li><a href="https://www.npmjs.com/package/lru-cache" target="_blank" rel="noreferrer">https://www.npmjs.com/package/lru-cache</a></li><li><a href="https://www.npmjs.com/package/tiny-lru" target="_blank" rel="noreferrer">https://www.npmjs.com/package/tiny-lru</a></li><li><a href="https://www.npmjs.com/package/mnemonist" target="_blank" rel="noreferrer">https://www.npmjs.com/package/mnemonist</a></li></ul><h2 id="连环问-不用-map-如何实现-lru-cache" tabindex="-1">连环问：不用 Map 如何实现 LRU cache ？ <a class="header-anchor" href="#连环问-不用-map-如何实现-lru-cache" aria-label="Permalink to &quot;连环问：不用 Map 如何实现 LRU cache ？&quot;">​</a></h2><p>LRU cache 是很早就有的算法，而 Map 仅仅是这几年才加入的 ES 语法。</p><h3 id="使用-object-和-array" tabindex="-1">使用 Object 和 Array <a class="header-anchor" href="#使用-object-和-array" aria-label="Permalink to &quot;使用 Object 和 Array&quot;">​</a></h3><p>根据上文的分析，两个条件</p><ul><li>哈希表，可以用 <code>Object</code> 实现</li><li>有序，可以用 <code>Array</code> 实现</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 执行 lru.set(&#39;a&#39;, 1) lru.set(&#39;b&#39;, 2) lru.set(&#39;c&#39;, 3) 后的数据</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">c</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> data </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [obj1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> obj2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> obj3]</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> obj1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> obj2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">c</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> obj3 </span><span style="color:#89DDFF;">}</span></span></code></pre></div><p>模拟 <code>get</code> <code>set</code> 操作，会发现几个问题，都来自于数组</p><ul><li>超出 cache 容量时，要移除最早的元素，数组 <code>shift</code> 效率低</li><li>每次 <code>get</code> <code>set</code> 时都要把当前元素移动到最新的位置，数组 <code>splice</code> 效率低</li></ul><h3 id="array-改为双向链表" tabindex="-1">Array 改为双向链表 <a class="header-anchor" href="#array-改为双向链表" aria-label="Permalink to &quot;Array 改为双向链表&quot;">​</a></h3><p>数组有问题，就需要使用新的数据结构 <strong>双向链表</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Interface INode </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">any</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">next</span><span style="color:#89DDFF;">?:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">INode</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">prev</span><span style="color:#89DDFF;">?:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">INode</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>双向链表可以快速移动元素。末尾新增元素 D 很简单，开头删除 A 元素也很简单。</p><p><img src="`+o+'" alt="" data-fancybox="gallery"></p><p>要把中间的元素 B 移动到最后（如 LRU <code>set</code> <code>get</code> 时移动数据位置），只需要修改前后的指针即可，效率很高。</p><p><img src="'+p+'" alt="" data-fancybox="gallery"></p><h3 id="实现-1" tabindex="-1">实现 <a class="header-anchor" href="#实现-1" aria-label="Permalink to &quot;实现&quot;">​</a></h3><p>代码参考 LRU2.ts</p><p>注意事项</p><ul><li>数据结构如何定义，<code>data</code> 和链表分别存储什么</li><li>双向链表的操作（非常繁琐，写代码很容易出错，逻辑一定要清晰！！！）</li><li>链表 <code>node</code> 中要存储 <code>data.key</code> ，否则删除 <code>data</code> 需要遍历、效率低</li></ul>',36),c=[t];function r(y,C,D,A,F,i){return a(),l("div",null,c)}const u=s(e,[["render",r]]);export{h as __pageData,u as default};
