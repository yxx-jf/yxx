import{_ as e,c as a,o as t,a as r}from"./app.ad3b77f8.js";const _=JSON.parse('{"title":"requestIdleCallback和requestAnimationFrame有什么区别","description":"","frontmatter":{},"headers":[{"level":2,"title":"requestAnimationFrame 每次渲染都执行，高优","slug":"requestanimationframe-每次渲染都执行-高优","link":"#requestanimationframe-每次渲染都执行-高优","children":[]},{"level":2,"title":"requestIdleCallback 空闲时才执行，低优","slug":"requestidlecallback-空闲时才执行-低优","link":"#requestidlecallback-空闲时才执行-低优","children":[]},{"level":2,"title":"宏任务","slug":"宏任务","link":"#宏任务","children":[]},{"level":2,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}],"relativePath":"interview/知识深度-原理和源码/08-requestIdleCallback和requestAnimationFrame有什么区别.md"}'),l={name:"interview/知识深度-原理和源码/08-requestIdleCallback和requestAnimationFrame有什么区别.md"},i=r('<h1 id="requestidlecallback和requestanimationframe有什么区别" tabindex="-1">requestIdleCallback和requestAnimationFrame有什么区别 <a class="header-anchor" href="#requestidlecallback和requestanimationframe有什么区别" aria-hidden="true">#</a></h1><ul><li><code>requestAnimationFrame</code> 每次渲染完都会执行，高优</li><li><code>requestIdleCallback</code> 空闲时才执行，低优</li></ul><h2 id="requestanimationframe-每次渲染都执行-高优" tabindex="-1">requestAnimationFrame 每次渲染都执行，高优 <a class="header-anchor" href="#requestanimationframe-每次渲染都执行-高优" aria-hidden="true">#</a></h2><p>页面的渲染是一帧一帧进行的，至少每秒 60 次（即 16.6ms 一次）才能肉眼感觉流畅。所以，网页动画也要这个帧率才能流畅。</p><p>用 JS 来控制时间是不靠谱的，因为 JS 执行本身还需要时间，而且 JS 和 DOM 渲染线程互斥。所以 ms 级别的时间会出现误差。<br><code>requestAnimationFrame</code> 就解决了这个问题，浏览器每次渲染都会执行，不用自己计算时间。</p><p>代码参考 requestAnimationFrame.html</p><h2 id="requestidlecallback-空闲时才执行-低优" tabindex="-1">requestIdleCallback 空闲时才执行，低优 <a class="header-anchor" href="#requestidlecallback-空闲时才执行-低优" aria-hidden="true">#</a></h2><p>requestIdleCallback 会在网页渲染完成后，CPU 空闲时执行，不一定每一帧都执行。</p><p>requestIdleCallback 不适合执行 DOM 操作，因为修改了 DOM 之后下一帧不一定会触发修改。</p><h2 id="宏任务" tabindex="-1">宏任务 <a class="header-anchor" href="#宏任务" aria-hidden="true">#</a></h2><p>requestAnimationFrame 和 requestIdleCallback 都是宏任务，它们比 setTimeout 更晚触发。</p><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-hidden="true">#</a></h2><p>requestAnimationFrame 可用于网页动画。</p><p>requestIdleCallback 可用于一些低优先级的场景，以代替 setTimeout 。例如发送统计数据。<br> 但请注意 requestIdleCallback 的浏览器兼容性</p>',14),n=[i];function s(d,c,u,o,m,h){return t(),a("div",null,n)}const p=e(l,[["render",s]]);export{_ as __pageData,p as default};
