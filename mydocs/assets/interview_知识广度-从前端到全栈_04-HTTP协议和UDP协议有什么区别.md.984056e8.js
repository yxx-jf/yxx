import{_ as e,c as l,o as i,a as t}from"./app.ad3b77f8.js";const a="/mydocs/网络协议.png",T=JSON.parse('{"title":"HTTP协议和UDP协议有什么区别","description":"","frontmatter":{},"headers":[{"level":2,"title":"网络协议","slug":"网络协议","link":"#网络协议","children":[]},{"level":2,"title":"TCP协议","slug":"tcp协议","link":"#tcp协议","children":[]},{"level":2,"title":"UDP 协议","slug":"udp-协议","link":"#udp-协议","children":[]},{"level":2,"title":"http 1.0 1.1 2.0 区别","slug":"http-1-0-1-1-2-0-区别","link":"#http-1-0-1-1-2-0-区别","children":[]}],"relativePath":"interview/知识广度-从前端到全栈/04-HTTP协议和UDP协议有什么区别.md"}'),d={name:"interview/知识广度-从前端到全栈/04-HTTP协议和UDP协议有什么区别.md"},c=t('<h1 id="http协议和udp协议有什么区别" tabindex="-1">HTTP协议和UDP协议有什么区别 <a class="header-anchor" href="#http协议和udp协议有什么区别" aria-hidden="true">#</a></h1><ul><li>HTTP 是应用层，TCP UDP 是传输层</li><li>TCP 有连接，有断开，稳定传输</li><li>UDP 无连接，无断开，不稳定传输，但效率高</li></ul><h2 id="网络协议" tabindex="-1">网络协议 <a class="header-anchor" href="#网络协议" aria-hidden="true">#</a></h2><ul><li>HTTP 协议在应用层</li><li>TCP UDP 协议再传输层</li><li>严格来说，应该拿TCP和UDP进行比较</li></ul><p><img src="'+a+'" alt="" data-fancybox="gallery"></p><h2 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-hidden="true">#</a></h2><ul><li>有连接(三次握手)</li><li>有断开(四次挥手)</li><li>稳定传输</li></ul><h2 id="udp-协议" tabindex="-1">UDP 协议 <a class="header-anchor" href="#udp-协议" aria-hidden="true">#</a></h2><ul><li>无连接，无断开</li><li>不稳定传输，但效率高</li><li>如视频会议、语音通话</li></ul><h2 id="http-1-0-1-1-2-0-区别" tabindex="-1">http 1.0 1.1 2.0 区别 <a class="header-anchor" href="#http-1-0-1-1-2-0-区别" aria-hidden="true">#</a></h2><p>http 1.0</p><ul><li>最基础的 http 协议</li><li>支持基本的GET POST方法</li></ul><p>http 1.1</p><ul><li>引入更多的缓存策略，如 <code>cache-control</code> <code>E-tag</code></li><li>支持长链接，默认开启 <code>Connection: keep-alive</code> ，一次 TCP 连接多次请求（多次 http 请求减少了 TCP 连接次数）</li><li>断点续传，状态码 <code>206</code></li><li>增加新的方法 <code>PUT</code> <code>DELETE</code> 等，可以设计 Restful API</li></ul><p>http2.0</p><ul><li>header 可压缩，以减少体积</li><li>多路复用，一个 TCP 连接中可以多个 http 并行请求。这样的话拼接资源（如雪碧图、多 js 拼接一个）将变的多余</li><li>服务器端推送</li></ul>',16),h=[c];function r(n,o,p,s,_,u){return i(),l("div",null,h)}const f=e(d,[["render",r]]);export{T as __pageData,f as default};
