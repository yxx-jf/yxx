import{_ as s,c as i,o as t,ae as e}from"./chunks/framework.DJWEhhqZ.js";const c=JSON.parse('{"title":"Array flatten","description":"","frontmatter":{},"headers":[],"relativePath":"interview/编写高质量代码/02-array-flatten.md","filePath":"interview/编写高质量代码/02-array-flatten.md"}'),n={name:"interview/编写高质量代码/02-array-flatten.md"};function l(h,a,r,p,k,d){return t(),i("div",null,[...a[0]||(a[0]=[e(`<h1 id="array-flatten" tabindex="-1">Array flatten <a class="header-anchor" href="#array-flatten" aria-label="Permalink to &quot;Array flatten&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>写一个函数，实现 Array flatten 扁平化，只减少一个嵌套层级<br> 例如输入 <code>[1, 2, [3, 4, [100, 200], 5], 6]</code> 返回 <code>[1, 2, 3, 4, [100, 200], 5, 6]</code></p><h2 id="解答" tabindex="-1">解答 <a class="header-anchor" href="#解答" aria-label="Permalink to &quot;解答&quot;">​</a></h2><ul><li>遍历数组</li><li>如果 item 是数字，则累加</li><li>如果 item 是数组，则 forEach 累加其元素</li></ul><p>代码参考 array-flatten.ts</p><h2 id="连环问-如果想要彻底扁平-忽略所有嵌套层级" tabindex="-1">连环问：如果想要彻底扁平，忽略所有嵌套层级？ <a class="header-anchor" href="#连环问-如果想要彻底扁平-忽略所有嵌套层级" aria-label="Permalink to &quot;连环问：如果想要彻底扁平，忽略所有嵌套层级？&quot;">​</a></h2><p>像 lodash <a href="https://www.lodashjs.com/docs/lodash.flattenDepth" target="_blank" rel="noreferrer">flattenDepth</a> ，例如输入 <code>[1, 2, [3, 4, [100, 200], 5], 6]</code> 返回 <code>[1, 2, 3, 4, 100, 200, 5, 6]</code></p><p>最容易想到的解决方案就是<strong>递归</strong>，代码参考 array-flatten-deep.ts （注意单元测试，有全面的数据类型）</p><p>还有一种 hack 的方式 <code>toString</code> —— 但遇到引用类型的 item 就不行了。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nums.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;1,2,3,4,100,200,5,6&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 但万一数组元素是 {x: 100} 等引用类型，就不可以了</span></span></code></pre></div>`,11)])])}const E=s(n,[["render",l]]);export{c as __pageData,E as default};
