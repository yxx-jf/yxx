import{_ as s,c as a,o as l,ae as t}from"./chunks/framework.DJWEhhqZ.js";const h="/yxx/%E5%A0%86%E6%A8%A1%E5%9E%8B.png",n="/yxx/heap.png",e="/yxx/%E5%A0%86%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.png",y=JSON.parse('{"title":"堆（Heap）","description":"","frontmatter":{},"headers":[],"relativePath":"interview/alg/12-堆有什么特点，和二叉树的关系.md","filePath":"interview/alg/12-堆有什么特点，和二叉树的关系.md"}'),k={name:"interview/alg/12-堆有什么特点，和二叉树的关系.md"};function p(r,i,d,o,g,E){return l(),a("div",null,[...i[0]||(i[0]=[t('<h1 id="堆-heap" tabindex="-1">堆（Heap） <a class="header-anchor" href="#堆-heap" aria-label="Permalink to &quot;堆（Heap）&quot;">​</a></h1><blockquote><p>堆（Heap）是一种特殊的树形数据结构，是最高效的优先级队列，一般讨论的堆都是二叉堆；堆是一种特殊的完全二叉树。它的所有节点都大于等于或小于等于它的子节点。<code>JavaScript</code>中通常用数组表示堆。</p></blockquote><ul><li>堆是一种特殊的完全二叉树</li><li>最大堆：父节点 &gt;= 子节点</li><li>最小堆：父节点 &lt;= 子节点</li></ul><p><img src="'+h+'" alt="堆模型" data-fancybox="gallery"></p><h2 id="堆栈模型" tabindex="-1">堆栈模型 <a class="header-anchor" href="#堆栈模型" aria-label="Permalink to &quot;堆栈模型&quot;">​</a></h2><ul><li>JS代码执行时</li><li>变量类型分两种是由于其在内存中存储方式不同</li><li>值类型变量，存储在栈(基本类型)</li><li>引用型变量，存储在堆(引用类型)</li></ul><p><img src="'+n+'" alt="堆栈模型" data-fancybox="gallery"></p><h2 id="逻辑结构vs物理结构" tabindex="-1">逻辑结构VS物理结构 <a class="header-anchor" href="#逻辑结构vs物理结构" aria-label="Permalink to &quot;逻辑结构VS物理结构&quot;">​</a></h2><ul><li>堆，<strong>逻辑结构</strong>是一棵二叉树</li><li>但它<strong>物理结构</strong>是一个数组</li><li>数组:适合连续存储 + 节省空间（回顾堆栈模型）</li></ul><p><img src="'+e+`" alt="堆的物理结构" data-fancybox="gallery"></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//上图是一个堆（从小到大），可以用数组表示</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> heap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">81</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">82</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//忽略 0 节点</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点关系 i为该节点在数组中的下标</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parentIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//父节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> leftIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//左 子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rightIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//右 子节点</span></span></code></pre></div><h2 id="堆-vs-bst" tabindex="-1">堆 VS BST <a class="header-anchor" href="#堆-vs-bst" aria-label="Permalink to &quot;堆 VS BST&quot;">​</a></h2><ul><li>查询比BST慢</li><li>增删比BST快，维持平衡块</li><li>但整体的时间复杂度都在<code>O(logn)</code>级别，即树的高度</li></ul><h2 id="堆的使用场景" tabindex="-1">堆的使用场景 <a class="header-anchor" href="#堆的使用场景" aria-label="Permalink to &quot;堆的使用场景&quot;">​</a></h2><ul><li>特别适合“堆栈模型”</li><li>堆的数据，都是在栈中引用的，不需要从<code>root</code>遍历</li><li>堆恰巧是数组形式，根据栈的地址，可用<code>O(1)</code>找到目标</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>了解堆栈模型，堆的场景</li><li>掌握堆的特点，堆和BST</li><li>了解堆的逻辑结构和物理结构</li></ul>`,17)])])}const F=s(k,[["render",p]]);export{y as __pageData,F as default};
