import{_ as e,c as l,o as s,a as o}from"./app.f6e6c401.js";const y=JSON.parse('{"title":"虚拟DOM（vdom）真的很快吗","description":"","frontmatter":{},"headers":[{"level":2,"title":"vdom","slug":"vdom","link":"#vdom","children":[]},{"level":2,"title":"Vue React 等框架的价值","slug":"vue-react-等框架的价值","link":"#vue-react-等框架的价值","children":[]},{"level":2,"title":"对比 DOM 操作","slug":"对比-dom-操作","link":"#对比-dom-操作","children":[]}],"relativePath":"interview/知识深度-原理和源码/04-虚拟DOM（vdom）真的很快吗.md"}'),a={name:"interview/知识深度-原理和源码/04-虚拟DOM（vdom）真的很快吗.md"},n=o(`<h1 id="虚拟dom-vdom-真的很快吗" tabindex="-1">虚拟DOM（vdom）真的很快吗 <a class="header-anchor" href="#虚拟dom-vdom-真的很快吗" aria-hidden="true">#</a></h1><ul><li><code>vdom</code> 并不快，<code>JS</code> 直接操作<code>DOM</code>才是最快的</li><li>但“数据驱动视图”要有合适的技术方案，不能全部 <code>DOM</code>重建</li><li><code>vdom</code> 就是目前最合适的技术方案(并不是因为它快，而是合适)</li></ul><h2 id="vdom" tabindex="-1">vdom <a class="header-anchor" href="#vdom" aria-hidden="true">#</a></h2><blockquote><p>Virtual DOM，虚拟 DOM ，即用 JS 对象模拟 DOM 数据。是 React 最先提出来的概念。</p></blockquote><p>React 的 JSX ，Vue 的 template 其实都是语法糖，它们本质上都是一个函数，成为 <code>render 函数</code></p><ul><li><code>Virtual DOM</code>，虚拟DOM</li><li>用JS对象模拟<code>DOM节点</code>数据</li><li>由<code>React</code>最先推广使用</li></ul><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// JSX: &lt;p id=&quot;p1&quot;&gt;hello world&lt;/p&gt;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">render</span><span style="color:#89DDFF;">():</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">VNode</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">p</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> id</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">p1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">])</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>执行 render 函数返回的就是一个 vdom 对象，一般叫做 vnode（虚拟节点），对应 DOM Node</p><p>每次数据更新（如 React setState）render 函数都会生成 newVnode ，然后前后对比 <code>diff(vnode, newVnode)</code>，计算出需要修改的 DOM 节点，再做修改。</p><h2 id="vue-react-等框架的价值" tabindex="-1">Vue React 等框架的价值 <a class="header-anchor" href="#vue-react-等框架的价值" aria-hidden="true">#</a></h2><ul><li>组件化</li><li>数据视图分离，数据驱动试图-----核心</li><li>只关注业务数据，而不用再关心DOM变化</li><li>数据驱动视图，技术方案:vdom</li></ul><h2 id="对比-dom-操作" tabindex="-1">对比 DOM 操作 <a class="header-anchor" href="#对比-dom-操作" aria-hidden="true">#</a></h2><p>下面两者，哪个更快？—— 很明显，前者更快。</p><ul><li>jquery 时代：直接修改 DOM</li><li>框架时代：生成 vdom ，进行 diff 运算 --&gt; 修改 DOM</li></ul><p>但凡事都要有一个业务背景。如果页面功能越来越复杂，直接操作 DOM 代码将会难以阅读和维护，大家更希望要“数据视图分离，数据驱动视图”。</p><p>在这个前提下，哪个更快？ —— 当然是后者。因为业务复杂、代码混乱，将会导致很多无谓的 DOM 操作 —— <strong>DOM 操作是昂贵的</strong></p><ul><li>直接修改 DOM</li><li>生成 vdom ，进行 diff 运算 --&gt; 修改 DOM</li></ul><p>而相比于昂贵的 DOM 操作，JS 运算非常快。所以 JS 多做事情（vdom diff）是更优的选择。</p>`,18),t=[n];function p(c,d,r,i,D,F){return s(),l("div",null,t)}const _=e(a,[["render",p]]);export{y as __pageData,_ as default};
