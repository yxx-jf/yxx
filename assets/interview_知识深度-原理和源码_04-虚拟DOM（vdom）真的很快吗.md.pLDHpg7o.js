import{_ as e,c as a,o as s,ae as l}from"./chunks/framework.DJWEhhqZ.js";const k=JSON.parse('{"title":"虚拟DOM（vdom）真的很快吗","description":"","frontmatter":{},"headers":[],"relativePath":"interview/知识深度-原理和源码/04-虚拟DOM（vdom）真的很快吗.md","filePath":"interview/知识深度-原理和源码/04-虚拟DOM（vdom）真的很快吗.md"}'),t={name:"interview/知识深度-原理和源码/04-虚拟DOM（vdom）真的很快吗.md"};function d(o,i,n,p,h,r){return s(),a("div",null,[...i[0]||(i[0]=[l(`<h1 id="虚拟dom-vdom-真的很快吗" tabindex="-1">虚拟DOM（vdom）真的很快吗 <a class="header-anchor" href="#虚拟dom-vdom-真的很快吗" aria-label="Permalink to &quot;虚拟DOM（vdom）真的很快吗&quot;">​</a></h1><ul><li><code>vdom</code> 并不快，<code>JS</code> 直接操作<code>DOM</code>才是最快的</li><li>但“数据驱动视图”要有合适的技术方案，不能全部 <code>DOM</code>重建</li><li><code>vdom</code> 就是目前最合适的技术方案(并不是因为它快，而是合适)</li></ul><h2 id="vdom" tabindex="-1">vdom <a class="header-anchor" href="#vdom" aria-label="Permalink to &quot;vdom&quot;">​</a></h2><blockquote><p>Virtual DOM，虚拟 DOM ，即用 JS 对象模拟 DOM 数据。是 React 最先提出来的概念。</p></blockquote><p>React 的 JSX ，Vue 的 template 其实都是语法糖，它们本质上都是一个函数，成为 <code>render 函数</code></p><ul><li><code>Virtual DOM</code>，虚拟DOM</li><li>用JS对象模拟<code>DOM节点</code>数据</li><li>由<code>React</code>最先推广使用</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JSX: &lt;p id=&quot;p1&quot;&gt;hello world&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello world&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>执行 render 函数返回的就是一个 vdom 对象，一般叫做 vnode（虚拟节点），对应 DOM Node</p><p>每次数据更新（如 React setState）render 函数都会生成 newVnode ，然后前后对比 <code>diff(vnode, newVnode)</code>，计算出需要修改的 DOM 节点，再做修改。</p><h2 id="vue-react-等框架的价值" tabindex="-1">Vue React 等框架的价值 <a class="header-anchor" href="#vue-react-等框架的价值" aria-label="Permalink to &quot;Vue React 等框架的价值&quot;">​</a></h2><ul><li>组件化</li><li>数据视图分离，数据驱动试图-----核心</li><li>只关注业务数据，而不用再关心DOM变化</li><li>数据驱动视图，技术方案:vdom</li></ul><h2 id="对比-dom-操作" tabindex="-1">对比 DOM 操作 <a class="header-anchor" href="#对比-dom-操作" aria-label="Permalink to &quot;对比 DOM 操作&quot;">​</a></h2><p>下面两者，哪个更快？—— 很明显，前者更快。</p><ul><li>jquery 时代：直接修改 DOM</li><li>框架时代：生成 vdom ，进行 diff 运算 --&gt; 修改 DOM</li></ul><p>但凡事都要有一个业务背景。如果页面功能越来越复杂，直接操作 DOM 代码将会难以阅读和维护，大家更希望要“数据视图分离，数据驱动视图”。</p><p>在这个前提下，哪个更快？ —— 当然是后者。因为业务复杂、代码混乱，将会导致很多无谓的 DOM 操作 —— <strong>DOM 操作是昂贵的</strong></p><ul><li>直接修改 DOM</li><li>生成 vdom ，进行 diff 运算 --&gt; 修改 DOM</li></ul><p>而相比于昂贵的 DOM 操作，JS 运算非常快。所以 JS 多做事情（vdom diff）是更优的选择。</p>`,18)])])}const u=e(t,[["render",d]]);export{k as __pageData,u as default};
