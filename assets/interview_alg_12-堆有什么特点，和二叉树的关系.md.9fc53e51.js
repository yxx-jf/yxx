import{_ as s,o as a,c as l,O as n}from"./chunks/framework.1d9da8ae.js";const o="/mydocs/堆模型.png",e="/mydocs/heap.png",t="/mydocs/堆的物理结构.png",h=JSON.parse('{"title":"堆（Heap）","description":"","frontmatter":{},"headers":[],"relativePath":"interview/alg/12-堆有什么特点，和二叉树的关系.md","filePath":"interview/alg/12-堆有什么特点，和二叉树的关系.md"}'),p={name:"interview/alg/12-堆有什么特点，和二叉树的关系.md"},c=n('<h1 id="堆-heap" tabindex="-1">堆（Heap） <a class="header-anchor" href="#堆-heap" aria-label="Permalink to &quot;堆（Heap）&quot;">​</a></h1><blockquote><p>堆（Heap）是一种特殊的树形数据结构，是最高效的优先级队列，一般讨论的堆都是二叉堆；堆是一种特殊的完全二叉树。它的所有节点都大于等于或小于等于它的子节点。<code>JavaScript</code>中通常用数组表示堆。</p></blockquote><ul><li>堆是一种特殊的完全二叉树</li><li>最大堆：父节点 &gt;= 子节点</li><li>最小堆：父节点 &lt;= 子节点</li></ul><p><img src="'+o+'" alt="堆模型" data-fancybox="gallery"></p><h2 id="堆栈模型" tabindex="-1">堆栈模型 <a class="header-anchor" href="#堆栈模型" aria-label="Permalink to &quot;堆栈模型&quot;">​</a></h2><ul><li>JS代码执行时</li><li>变量类型分两种是由于其在内存中存储方式不同</li><li>值类型变量，存储在栈(基本类型)</li><li>引用型变量，存储在堆(引用类型)</li></ul><p><img src="'+e+'" alt="堆栈模型" data-fancybox="gallery"></p><h2 id="逻辑结构vs物理结构" tabindex="-1">逻辑结构VS物理结构 <a class="header-anchor" href="#逻辑结构vs物理结构" aria-label="Permalink to &quot;逻辑结构VS物理结构&quot;">​</a></h2><ul><li>堆，<strong>逻辑结构</strong>是一棵二叉树</li><li>但它<strong>物理结构</strong>是一个数组</li><li>数组:适合连续存储 + 节省空间（回顾堆栈模型）</li></ul><p><img src="'+t+`" alt="堆的物理结构" data-fancybox="gallery"></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//上图是一个堆（从小到大），可以用数组表示</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> heap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [ </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">14</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">25</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">33</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">81</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">82</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">99</span><span style="color:#A6ACCD;">]</span><span style="color:#676E95;font-style:italic;">//忽略 0 节点</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 节点关系 i为该节点在数组中的下标</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> parentIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">floor</span><span style="color:#A6ACCD;">(i </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span><span style="color:#676E95;font-style:italic;">//父节点</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> leftIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> i</span><span style="color:#676E95;font-style:italic;">//左 子节点</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> rightIndex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">+</span><span style="color:#F78C6C;">1</span><span style="color:#676E95;font-style:italic;">//右 子节点</span></span></code></pre></div><h2 id="堆-vs-bst" tabindex="-1">堆 VS BST <a class="header-anchor" href="#堆-vs-bst" aria-label="Permalink to &quot;堆 VS BST&quot;">​</a></h2><ul><li>查询比BST慢</li><li>增删比BST快，维持平衡块</li><li>但整体的时间复杂度都在<code>O(logn)</code>级别，即树的高度</li></ul><h2 id="堆的使用场景" tabindex="-1">堆的使用场景 <a class="header-anchor" href="#堆的使用场景" aria-label="Permalink to &quot;堆的使用场景&quot;">​</a></h2><ul><li>特别适合“堆栈模型”</li><li>堆的数据，都是在栈中引用的，不需要从<code>root</code>遍历</li><li>堆恰巧是数组形式，根据栈的地址，可用<code>O(1)</code>找到目标</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>了解堆栈模型，堆的场景</li><li>掌握堆的特点，堆和BST</li><li>了解堆的逻辑结构和物理结构</li></ul>`,17),r=[c];function i(y,C,D,A,d,_){return a(),l("div",null,r)}const u=s(p,[["render",i]]);export{h as __pageData,u as default};
