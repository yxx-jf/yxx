import{_ as d,c as i,o,a as e,e as c}from"./app.6bedd889.js";const l="/tree-diff.png",a="/tree-diff-1.png",f="/react-diff.png",t="/vue2-diff.png",r="/vue3-diff.png",T=JSON.parse('{"title":"Vue2和Vue3和React三者的diff 算法有什么区别","description":"","frontmatter":{},"headers":[{"level":2,"title":"diff算法","slug":"diff算法","link":"#diff算法","children":[]},{"level":2,"title":"Tree diff 的优化","slug":"tree-diff-的优化","link":"#tree-diff-的优化","children":[]},{"level":2,"title":"React diff 特点 - 仅向右移动","slug":"react-diff-特点-仅向右移动","link":"#react-diff-特点-仅向右移动","children":[]},{"level":2,"title":"Vue2 diff 特点 - 双端比较","slug":"vue2-diff-特点-双端比较","link":"#vue2-diff-特点-双端比较","children":[]},{"level":2,"title":"Vue3 diff 特点 - 最长递增子序列","slug":"vue3-diff-特点-最长递增子序列","link":"#vue3-diff-特点-最长递增子序列","children":[]}],"relativePath":"interview/知识深度-原理和源码/10-Vue2和Vue3和React三者的diff 算法有什么区别.md"}'),n={name:"interview/知识深度-原理和源码/10-Vue2和Vue3和React三者的diff 算法有什么区别.md"},s=e('<h1 id="vue2和vue3和react三者的diff-算法有什么区别" tabindex="-1">Vue2和Vue3和React三者的diff 算法有什么区别 <a class="header-anchor" href="#vue2和vue3和react三者的diff-算法有什么区别" aria-hidden="true">#</a></h1><ul><li>Vue2- 双端比较</li><li>Vue3- 最长递增子序列</li><li>React - 仅右移</li></ul><h2 id="diff算法" tabindex="-1">diff算法 <a class="header-anchor" href="#diff算法" aria-hidden="true">#</a></h2><blockquote><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 <code>O(n)</code>。<code>diff</code> 算法的在很多场景下都有应用，例如在 <code>vue</code> 虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较更新时，就用到了该算法。</p></blockquote><p><code>diff</code> 算法是一个非常普遍常用的方法，例如提交 <code>github</code> <code>pr</code> 或者（<code>gitlab</code> <code>mr</code>）时，会对比当前 提交代码的改动，这就是 <code>diff</code> 。</p><p><code>Vue React diff</code> 不是对比文字，而是 <code>vdom</code> 树，即 <code>tree diff</code> 。<br> 传统的 <code>tree diff</code> 算法复杂度是 <code>O(n^3)</code> ，算法不可用。</p><ul><li><code>diff</code> 算法很早就有</li><li><code>diff</code> 算法应用广泛，例如 <code>github</code> 的 <code>Pull Request</code> 中的代码 <code>diff</code></li><li>如果要严格 <code>diff</code> 两棵树，时间复杂度<code>O(n^3)</code>，不可用</li></ul><p><img src="'+l+'" alt="tree-diff" data-fancybox="gallery"></p><h2 id="tree-diff-的优化" tabindex="-1">Tree diff 的优化 <a class="header-anchor" href="#tree-diff-的优化" aria-hidden="true">#</a></h2><p><code>Vue React</code> 都是用于网页开发，基于 <code>DOM</code> 结构，对 <code>diff</code> 算法都进行了优化（或者简化）</p><ul><li>只在同一层级比较，不夸层级比较（<code>DOM</code> 结构的变化，很少有跨层级移动）</li><li><code>tag</code> 不同则直接删掉重建，不去对比内部细节（<code>DOM</code> 结构变化，很少有只改外层，不改内层）</li><li>同一个节点下的子节点，通过 <code>key</code> 区分</li></ul><p>最终把时间复杂度降低到 <code>O(n)</code> ，生产环境下可用。这一点 <code>Vue React</code> 都是相同的。</p><p><img src="'+a+'" alt="tree-diff-1" data-fancybox="gallery"></p><h2 id="react-diff-特点-仅向右移动" tabindex="-1">React diff 特点 - 仅向右移动 <a class="header-anchor" href="#react-diff-特点-仅向右移动" aria-hidden="true">#</a></h2><p>比较子节点时，仅向右移动，不向左移动。</p><p><img src="'+f+'" alt="" data-fancybox="gallery"></p><h2 id="vue2-diff-特点-双端比较" tabindex="-1">Vue2 diff 特点 - 双端比较 <a class="header-anchor" href="#vue2-diff-特点-双端比较" aria-hidden="true">#</a></h2><p><img src="'+t+'" alt="" data-fancybox="gallery"></p><p>定义四个指针，分别比较</p><ul><li>oldStartNode 和 newStartNode</li><li>oldStartNode 和 newEndNode</li><li>oldEndNode 和 newStartNode</li><li>oldEndNode 和 newEndNode</li></ul><p>然后指针继续向中间移动，知道指针汇合。</p><p>文字和图文难以描述，用视频讲解</p>',22),u=c("iframe",{src:"//player.bilibili.com/player.html?aid=778665635&bvid=BV1Ty4y1X7QY&cid=988989235&page=1&high_quality=1&danmaku=0",allowfullscreen:"allowfullscreen",width:"100%",height:"500",scrolling:"no",frameborder:"0",sandbox:"allow-top-navigation allow-same-origin allow-forms allow-scripts"},null,-1),_=e('<h2 id="vue3-diff-特点-最长递增子序列" tabindex="-1">Vue3 diff 特点 - 最长递增子序列 <a class="header-anchor" href="#vue3-diff-特点-最长递增子序列" aria-hidden="true">#</a></h2><p>例如数组 <code>[3，5，7，1，2，8]</code> 的最长递增子序列就是 <code>[3，5，7，8 ]</code> 。这是一个专门的算法。</p><p><img src="'+r+'" alt="" data-fancybox="gallery"></p><p>算法步骤</p><ul><li>通过“前-前”比较找到开始的不变节点 <code>[A, B]</code></li><li>通过“后-后”比较找到末尾的不变节点 <code>[G]</code></li><li>剩余的有变化的节点 <code>[F, C, D, E, H]</code><ul><li>通过 <code>newIndexToOldIndexMap</code> 拿到 oldChildren 中对应的 index <code>[5, 2, 3, 4, -1]</code> （<code>-1</code> 表示之前没有，要新增）</li><li>计算<strong>最长递增子序列</strong>得到 <code>[2, 3, 4]</code> ，对应的就是 <code>[C, D, E]</code> ，即这些节点可以不变</li><li>剩余的节点，根据 index 进行新增、删除</li></ul></li></ul><p>该方法旨在尽量减少 DOM 的移动，达到最少的 DOM 操作。</p>',6),p=[s,u,_];function h(m,g,v,V,b,y){return o(),i("div",null,p)}const w=d(n,[["render",h]]);export{T as __pageData,w as default};
