import{_ as i,c as a,o as h,ae as l}from"./chunks/framework.DJWEhhqZ.js";const n="/yxx/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1.png",e="/yxx/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-2.png",g=JSON.parse('{"title":"手写 LRU","description":"","frontmatter":{},"headers":[],"relativePath":"interview/编写高质量代码/11-手写LRU.md","filePath":"interview/编写高质量代码/11-手写LRU.md"}'),t={name:"interview/编写高质量代码/11-手写LRU.md"};function k(p,s,r,d,E,c){return h(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="手写-lru" tabindex="-1">手写 LRU <a class="header-anchor" href="#手写-lru" aria-label="Permalink to &quot;手写 LRU&quot;">​</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>用 JS 实现一个 LRU 缓存</p><h2 id="lru-使用" tabindex="-1">LRU 使用 <a class="header-anchor" href="#lru-使用" aria-label="Permalink to &quot;LRU 使用&quot;">​</a></h2><p>Least Recently Used 最近最少使用<br> 即淘汰掉最近最少使用的数据，只保留最近经常使用的资源。它是一个固定容量的缓存容器。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lruCache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LRUCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 最大缓存长度 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 缓存是 {1=1}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 缓存是 {1=1, 2=2}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lruCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 4</span></span></code></pre></div><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><ul><li>哈希表，即 <code>{ k1: v1, k2: v2, ... }</code> 形式。可以 <code>O(1)</code> 事件复杂度存取 <code>key</code> <code>value</code></li><li>有序。可以根据最近使用情况清理缓存</li></ul><p>JS 内置的数据结构类型 <code>Object</code> <code>Array</code> <code>Set</code> <code>Map</code> ，恰好 <code>Map</code> 符合这两条要求</p><h2 id="map-是有序的" tabindex="-1">Map 是有序的 <a class="header-anchor" href="#map-是有序的" aria-label="Permalink to &quot;Map 是有序的&quot;">​</a></h2><p>Map 有序，Object 无序</p><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2><p>代码参考 LRU.ts</p><p>注意，<code>get</code> <code>set</code> 时都要把操作数据移动到 Map 最新的位置。</p><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>实际项目中可以使用第三方 lib</p><ul><li><a href="https://www.npmjs.com/package/quick-lru" target="_blank" rel="noreferrer">https://www.npmjs.com/package/quick-lru</a></li><li><a href="https://www.npmjs.com/package/lru-cache" target="_blank" rel="noreferrer">https://www.npmjs.com/package/lru-cache</a></li><li><a href="https://www.npmjs.com/package/tiny-lru" target="_blank" rel="noreferrer">https://www.npmjs.com/package/tiny-lru</a></li><li><a href="https://www.npmjs.com/package/mnemonist" target="_blank" rel="noreferrer">https://www.npmjs.com/package/mnemonist</a></li></ul><h2 id="连环问-不用-map-如何实现-lru-cache" tabindex="-1">连环问：不用 Map 如何实现 LRU cache ？ <a class="header-anchor" href="#连环问-不用-map-如何实现-lru-cache" aria-label="Permalink to &quot;连环问：不用 Map 如何实现 LRU cache ？&quot;">​</a></h2><p>LRU cache 是很早就有的算法，而 Map 仅仅是这几年才加入的 ES 语法。</p><h3 id="使用-object-和-array" tabindex="-1">使用 Object 和 Array <a class="header-anchor" href="#使用-object-和-array" aria-label="Permalink to &quot;使用 Object 和 Array&quot;">​</a></h3><p>根据上文的分析，两个条件</p><ul><li>哈希表，可以用 <code>Object</code> 实现</li><li>有序，可以用 <code>Array</code> 实现</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行 lru.set(&#39;a&#39;, 1) lru.set(&#39;b&#39;, 2) lru.set(&#39;c&#39;, 3) 后的数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [obj1, obj2, obj3]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: obj1, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: obj2, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: obj3 }</span></span></code></pre></div><p>模拟 <code>get</code> <code>set</code> 操作，会发现几个问题，都来自于数组</p><ul><li>超出 cache 容量时，要移除最早的元素，数组 <code>shift</code> 效率低</li><li>每次 <code>get</code> <code>set</code> 时都要把当前元素移动到最新的位置，数组 <code>splice</code> 效率低</li></ul><h3 id="array-改为双向链表" tabindex="-1">Array 改为双向链表 <a class="header-anchor" href="#array-改为双向链表" aria-label="Permalink to &quot;Array 改为双向链表&quot;">​</a></h3><p>数组有问题，就需要使用新的数据结构 <strong>双向链表</strong></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Interface INode {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: any</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>双向链表可以快速移动元素。末尾新增元素 D 很简单，开头删除 A 元素也很简单。</p><p><img src="`+n+'" alt="" data-fancybox="gallery"></p><p>要把中间的元素 B 移动到最后（如 LRU <code>set</code> <code>get</code> 时移动数据位置），只需要修改前后的指针即可，效率很高。</p><p><img src="'+e+'" alt="" data-fancybox="gallery"></p><h3 id="实现-1" tabindex="-1">实现 <a class="header-anchor" href="#实现-1" aria-label="Permalink to &quot;实现&quot;">​</a></h3><p>代码参考 LRU2.ts</p><p>注意事项</p><ul><li>数据结构如何定义，<code>data</code> 和链表分别存储什么</li><li>双向链表的操作（非常繁琐，写代码很容易出错，逻辑一定要清晰！！！）</li><li>链表 <code>node</code> 中要存储 <code>data.key</code> ，否则删除 <code>data</code> 需要遍历、效率低</li></ul>',36)])])}const y=i(t,[["render",k]]);export{g as __pageData,y as default};
